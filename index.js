var through = require('through2');
var gutil = require('gulp-util');
var PluginError = gutil.PluginError;
var path = require('path');
var jadeParser = require('jade').Parser;
var PO = require('node-po');
var extend = require('util')._extend;

// consts
const PLUGIN_NAME = 'gulp-jade-l10n-extractor';

function log(title, what) {
  title = title ? (gutil.colors.cyan(title)) : '';
  gutil.log(title + what);
}

var fileHeader = "# Generated by gulp-jade-l10n-extractor\n\n";

function processBlock(block, file)
{
  var messages = [];

  block.nodes.forEach(function (node) {
    node.attrs && node.attrs.forEach(function (attr) {
      if (attr.name === "l10n") {
        // Replace &#32; with space and trim
        var text = parseText(node).replace(/&#32;/g,' ').replace(/^\s+|\s+$/gm, '');

        // Skip empty nodes
        if ("string" !== typeof attr.val && text === '') {
          return;
        }

        messages.push({
          file: path.relative(file.cwd, file.path),
          line: node.line,
          msgid: ("string" === typeof attr.val) ? attr.val : text,
          msgstr: text
        });
      }
      else {
        var translatableTag = /l10n-([-a-zA-Z0-9]*)/g.exec(attr.name);

        if (translatableTag && translatableTag[1] !== 'inc') {
          messages.push({
            file: path.relative(file.cwd, file.path),
            line: node.line,
            msgid: attr.val,
            msgstr: attr.val
          });
        }
      }
    });

    node.block && (messages = messages.concat(processBlock(node.block, file)));
  });

  return messages;
}

function parseText(node)
{
  var textPieces = [], counter = 1;

  node.block.nodes.forEach(function (node) {
    var nodeText = '';
    if (node.name) {
      var alias = String(counter++), content = '';
      node.attrs && node.attrs.forEach(function (attr) {
        if (attr.name === "l10n-inc") {
          content = ":" + parseText(node);
        }
      });

      if (node.block.nodes[0] && node.block.nodes[0].val
        && 0 === node.block.nodes[0].val.indexOf(" ")) {
        nodeText += " ";
      }

      nodeText += "{{";
      nodeText += alias;
      nodeText += content;
      nodeText += "}}";
      textPieces.push(nodeText);
    } else if ("string" === typeof node.val) {
      textPieces.push(node.val);
    }
  });

  return escapeString(textPieces.join(''));
}

function escapeString(str) {
  // http://kevin.vanzonneveld.net
  // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +   improved by: Ates Goral (http://magnetiq.com)
  // +   improved by: marrtins
  // +   improved by: Nate
  // +   improved by: Onno Marsman
  // +   input by: Denny Wardhana
  // +   improved by: Brett Zamir (http://brett-zamir.me)
  // +   improved by: Oskar Larsson HÃ¶gfeldt (http://oskar-lh.name/)
  // *     example 1: addslashes("kevin's birthday");
  // *     returns 1: 'kevin\'s birthday'
  return (str + '').replace(/[\\"]/g, '\\$&').replace(/\u0000/g, '\\0');
}

// exporting the plugin main function
module.exports = function(options) {
  var po = new PO();
  po.headers["MIME-Version"] = "1.0";
  po.headers["Content-Type"] = "text/plain; charset=UTF-8";
  po.headers["Content-Transfer-Encoding"] = "8bit";

  var msgIndex = {};
  var hasCollisions = false;
  var messagesCount = 0;

  // creating a stream through which each file will pass
  var stream = through.obj(function(file, enc, cb) {
    var messages = [];

    if (file.isStream()){
      return cb(new PluginError(PLUGIN_NAME, 'Streaming not supported'));
    }

    if (file.isBuffer()){
      try {
        var parser = new jadeParser(file.contents.toString(), file.path);
        var doc = parser.parse();
      } catch (e) {
        return cb(new PluginError(PLUGIN_NAME, e.message + ' File: ' + file.path));
      }

      try {
        messages = messages
          .concat(processBlock(doc, file))
          .filter(function (msg) {
            var poItem;

            if ("object" === typeof msgIndex[msg.msgid]) {
              poItem = msgIndex[msg.msgid];
              if (poItem.msgstr !== msg.msgstr) {
                hasCollisions = true;
                // TODO better logging
                log("Two messages with the same ID, but different strings:");
                log(poItem.file + ":" + poItem.line);
                log(msg.file + ":" + msg.line);
                log("both have ID '" + msg.msgid + "'");
              } else {
                poItem.references.push(msg.file + ":" + msg.line);
              }
            } else {
              poItem = new PO.Item();
              poItem.msgid = msg.msgid;
              poItem.msgstr = msg.msgstr;
              poItem.references = [msg.file + ":" + msg.line];
              if (msg.msgid !== msg.msgstr) {
                poItem.comments.push(msg.msgid);
              }
              msgIndex[msg.msgid] = poItem;
              po.items.push(poItem);

              return true;
            }
          });

        if (hasCollisions) {
          new PluginError(PLUGIN_NAME, 'Duplicate ID');
          return cb();
        }
      } catch (e) {
        return cb(new PluginError(PLUGIN_NAME, e));
      }
    }

    messagesCount += messages.length;

    // tell the stream engine that we are done with this file
    cb();
  }, function (){
    var languageFile = new gutil.File({
      path: options.filename,
      contents: new Buffer(fileHeader + po.toString())
    });

    log('Imported l10n strings: ', messagesCount);
    stream.push(languageFile);
  });

  // returning the file stream
  return stream;
};
